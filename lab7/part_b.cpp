#include <iostream>
#include <string>
#include <Windows.h>
#include <memoryapi.h>
#include <libloaderapi.h>

typedef HRESULT(CALLBACK* LPFNDLLFUNC1)(DWORD, UINT*);

int main(int argc, char* argv[]) {
	if (argc < 3) {
		std::cout << "Not enough arguments provided" << std::endl;
		return 1;
	}

	std::string dll_name = argv[1];
	int pid = std::stoi(argv[2]);

	HANDLE hVictimProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);
	if (hVictimProcess == NULL)
		std::cout << "Unable to open proccess" << std::endl;

	LPVOID pNameInVictimeProcess = (LPVOID)VirtualAllocEx(hVictimProcess, NULL, strlen(argv[1]) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (pNameInVictimeProcess == NULL)
		std::cout << "Unable to allocate memory" << std::endl;

	int n = WriteProcessMemory(hVictimProcess, pNameInVictimeProcess, argv[1], strlen(argv[1]) + 1, NULL);
	if (n == 0)
		std::cout << "No bytes written in process memory" << std::endl;

	HMODULE hModule = GetModuleHandle(L"kernel32.dll");
	if (hModule == NULL)
		std::cout << "Unable to load kernel32" << std::endl;

	LPVOID procAddress = (LPVOID)GetProcAddress(hModule, "LoadLibraryA");
	if (procAddress == NULL)
		std::cout << "Unable to find LoadLibraryA" << std::endl;

	HANDLE thread = CreateRemoteThread(hVictimProcess, NULL, 32, (LPTHREAD_START_ROUTINE)procAddress, pNameInVictimeProcess, 0, NULL);
	if (thread == NULL)
		std::cout << "Failed to create thread: " << GetLastError() << std::endl;
	else
		std::cout << "Remote thread created" << std::endl;

	CloseHandle(hVictimProcess);

	return 0;
}